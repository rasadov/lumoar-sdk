/* tslint:disable */
/* eslint-disable */
/**
 * Lumoar API
 * Compliance as a service
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Authentication success response schema. Attributes:     - access_token: str     - token_type: str     - user_id: str     - role: str
 * @export
 * @interface AuthenticationSuccess
 */
export interface AuthenticationSuccess {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AuthenticationSuccess
     */
    'detail': { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AuthenticationSuccess
     */
    'access_token': string;
    /**
     * 
     * @type {UserInDBBase}
     * @memberof AuthenticationSuccess
     */
    'user'?: UserInDBBase;
}
/**
 * 
 * @export
 * @interface CheckoutSessionResponse
 */
export interface CheckoutSessionResponse {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionResponse
     */
    'checkout_url': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionResponse
     */
    'session_id': string;
}
/**
 * 
 * @export
 * @interface CompanyCreate
 */
export interface CompanyCreate {
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'industry': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyCreate
     */
    'employee_count': number;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'domain': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CompanyCreate
     */
    'tools_used'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'plan'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'status'?: string | null;
    /**
     * 
     * @type {ComplianceGoal}
     * @memberof CompanyCreate
     */
    'compliance_goal'?: ComplianceGoal | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyCreate
     */
    'readiness_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'audit_due_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyCreate
     */
    'is_audit_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyCreate
     */
    'logo_url'?: string | null;
}


/**
 * 
 * @export
 * @interface CompanyInDBBase
 */
export interface CompanyInDBBase {
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'industry': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyInDBBase
     */
    'employee_count': number;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'domain': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CompanyInDBBase
     */
    'tools_used'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'plan'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'status'?: string | null;
    /**
     * 
     * @type {ComplianceGoal}
     * @memberof CompanyInDBBase
     */
    'compliance_goal'?: ComplianceGoal | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyInDBBase
     */
    'readiness_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'audit_due_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyInDBBase
     */
    'is_audit_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyInDBBase
     */
    'updated_at': string;
}


/**
 * 
 * @export
 * @interface CompanyUpdate
 */
export interface CompanyUpdate {
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    'industry'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyUpdate
     */
    'employee_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    'domain'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CompanyUpdate
     */
    'tools_used'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {ComplianceGoal}
     * @memberof CompanyUpdate
     */
    'compliance_goal'?: ComplianceGoal | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyUpdate
     */
    'readiness_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    'audit_due_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyUpdate
     */
    'is_audit_mode'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    'timezone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyUpdate
     */
    'logo_url'?: string | null;
}


/**
 * 
 * @export
 * @interface CompanyWithControls
 */
export interface CompanyWithControls {
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'industry': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyWithControls
     */
    'employee_count': number;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'domain': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CompanyWithControls
     */
    'tools_used'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'plan'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'status'?: string | null;
    /**
     * 
     * @type {ComplianceGoal}
     * @memberof CompanyWithControls
     */
    'compliance_goal'?: ComplianceGoal | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyWithControls
     */
    'readiness_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'audit_due_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyWithControls
     */
    'is_audit_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithControls
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<ControlWithEvidences>}
     * @memberof CompanyWithControls
     */
    'controls': Array<ControlWithEvidences>;
}


/**
 * 
 * @export
 * @interface CompanyWithRoles
 */
export interface CompanyWithRoles {
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'industry': string;
    /**
     * 
     * @type {number}
     * @memberof CompanyWithRoles
     */
    'employee_count': number;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'domain': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CompanyWithRoles
     */
    'tools_used'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'plan'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'status'?: string | null;
    /**
     * 
     * @type {ComplianceGoal}
     * @memberof CompanyWithRoles
     */
    'compliance_goal'?: ComplianceGoal | null;
    /**
     * 
     * @type {number}
     * @memberof CompanyWithRoles
     */
    'readiness_score'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'audit_due_date'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CompanyWithRoles
     */
    'is_audit_mode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'logo_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CompanyWithRoles
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<RolesWithUser>}
     * @memberof CompanyWithRoles
     */
    'permissions': Array<RolesWithUser>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ComplianceGoal = {
    Soc2: 'SOC2'
} as const;

export type ComplianceGoal = typeof ComplianceGoal[keyof typeof ComplianceGoal];


/**
 * 
 * @export
 * @enum {string}
 */

export const ControlStatus = {
    NotStarted: 'not_started',
    InProgress: 'in_progress',
    Completed: 'completed',
    Failed: 'failed',
    Skipped: 'skipped',
    PendingReview: 'pending_review'
} as const;

export type ControlStatus = typeof ControlStatus[keyof typeof ControlStatus];


/**
 * 
 * @export
 * @interface ControlWithEvidences
 */
export interface ControlWithEvidences {
    /**
     * 
     * @type {string}
     * @memberof ControlWithEvidences
     */
    'id': string;
    /**
     * 
     * @type {FrameworkControlsBase}
     * @memberof ControlWithEvidences
     */
    'framework_control': FrameworkControlsBase;
    /**
     * 
     * @type {string}
     * @memberof ControlWithEvidences
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ControlWithEvidences
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ControlWithEvidences
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {Array<EvidenceBase>}
     * @memberof ControlWithEvidences
     */
    'evidences'?: Array<EvidenceBase>;
}
/**
 * 
 * @export
 * @interface ControlWithRelationships
 */
export interface ControlWithRelationships {
    /**
     * 
     * @type {string}
     * @memberof ControlWithRelationships
     */
    'id': string;
    /**
     * 
     * @type {FrameworkControlsBase}
     * @memberof ControlWithRelationships
     */
    'framework_control': FrameworkControlsBase;
    /**
     * 
     * @type {string}
     * @memberof ControlWithRelationships
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ControlWithRelationships
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ControlWithRelationships
     */
    'updated_at'?: string | null;
    /**
     * 
     * @type {CompanyInDBBase}
     * @memberof ControlWithRelationships
     */
    'company': CompanyInDBBase;
    /**
     * 
     * @type {Array<EvidenceBase>}
     * @memberof ControlWithRelationships
     */
    'evidences'?: Array<EvidenceBase>;
}
/**
 * 
 * @export
 * @interface CustomerDoesNotExist
 */
export interface CustomerDoesNotExist {
    /**
     * 
     * @type {string}
     * @memberof CustomerDoesNotExist
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CustomerPortalSession
 */
export interface CustomerPortalSession {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof CustomerPortalSession
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface Details
 */
export interface Details {
    /**
     * 
     * @type {string}
     * @memberof Details
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface EvidenceBase
 */
export interface EvidenceBase {
    /**
     * 
     * @type {string}
     * @memberof EvidenceBase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceBase
     */
    'control_id': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceBase
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof EvidenceBase
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof EvidenceBase
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceBase
     */
    'type': string;
    /**
     * 
     * @type {EvidenceTextSchema}
     * @memberof EvidenceBase
     */
    'text'?: EvidenceTextSchema | null;
    /**
     * 
     * @type {Array<EvidenceFileSchema>}
     * @memberof EvidenceBase
     */
    'files'?: Array<EvidenceFileSchema> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof EvidenceBase
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {UserBase}
     * @memberof EvidenceBase
     */
    'uploaded_by'?: UserBase | null;
    /**
     * 
     * @type {string}
     * @memberof EvidenceBase
     */
    'submitted_at'?: string | null;
}
/**
 * 
 * @export
 * @interface EvidenceFileSchema
 */
export interface EvidenceFileSchema {
    /**
     * 
     * @type {number}
     * @memberof EvidenceFileSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceFileSchema
     */
    'evidence_id': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceFileSchema
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceFileSchema
     */
    'storage_key': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceFileSchema
     */
    'checksum': string;
    /**
     * 
     * @type {number}
     * @memberof EvidenceFileSchema
     */
    'file_size': number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceFileSchema
     */
    'file_type': string;
}
/**
 * 
 * @export
 * @interface EvidenceTextSchema
 */
export interface EvidenceTextSchema {
    /**
     * 
     * @type {number}
     * @memberof EvidenceTextSchema
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof EvidenceTextSchema
     */
    'evidence_id': string;
    /**
     * 
     * @type {string}
     * @memberof EvidenceTextSchema
     */
    'content': string;
}
/**
 * 
 * @export
 * @interface FileDownload
 */
export interface FileDownload {
    /**
     * 
     * @type {string}
     * @memberof FileDownload
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FileDownload
     */
    'filename'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FileDownload
     */
    'file_size'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FileDownload
     */
    'file_type'?: string | null;
}
/**
 * 
 * @export
 * @interface FrameworkControlsBase
 */
export interface FrameworkControlsBase {
    /**
     * 
     * @type {string}
     * @memberof FrameworkControlsBase
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FrameworkControlsBase
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof FrameworkControlsBase
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FrameworkControlsBase
     */
    'control_key': string;
}
/**
 * 
 * @export
 * @interface GetControl
 */
export interface GetControl {
    /**
     * 
     * @type {ControlWithRelationships}
     * @memberof GetControl
     */
    'control': ControlWithRelationships;
    /**
     * 
     * @type {UserRole}
     * @memberof GetControl
     */
    'role': UserRole;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InviteToCompany
 */
export interface InviteToCompany {
    /**
     * 
     * @type {string}
     * @memberof InviteToCompany
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof InviteToCompany
     */
    'company_id': string;
    /**
     * 
     * @type {PermissionType}
     * @memberof InviteToCompany
     */
    'role': PermissionType;
}


/**
 * Login schema for user authentication. Attributes:     - email: EmailStr     - password: SecretStr     - turnstile_token: str
 * @export
 * @interface LoginSchema
 */
export interface LoginSchema {
    /**
     * 
     * @type {string}
     * @memberof LoginSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginSchema
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof LoginSchema
     */
    'turnstile_token': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PermissionType = {
    Owner: 'owner',
    Admin: 'admin',
    Member: 'member',
    Auditor: 'auditor'
} as const;

export type PermissionType = typeof PermissionType[keyof typeof PermissionType];


/**
 * 
 * @export
 * @interface PolicyCreate
 */
export interface PolicyCreate {
    /**
     * Name of the policy
     * @type {string}
     * @memberof PolicyCreate
     */
    'name': string;
    /**
     * Type of policy (e.g., \'security\', \'privacy\')
     * @type {string}
     * @memberof PolicyCreate
     */
    'type': string;
    /**
     * Policy content as a JSON object
     * @type {{ [key: string]: any; }}
     * @memberof PolicyCreate
     */
    'content': { [key: string]: any; };
    /**
     * UUID of the company this policy belongs to
     * @type {string}
     * @memberof PolicyCreate
     */
    'company_id': string;
}
/**
 * 
 * @export
 * @interface PolicyRead
 */
export interface PolicyRead {
    /**
     * Unique identifier for the policy
     * @type {string}
     * @memberof PolicyRead
     */
    'id': string;
    /**
     * Name of the policy
     * @type {string}
     * @memberof PolicyRead
     */
    'name': string;
    /**
     * Type of policy
     * @type {string}
     * @memberof PolicyRead
     */
    'type': string;
    /**
     * Policy content
     * @type {{ [key: string]: any; }}
     * @memberof PolicyRead
     */
    'content': { [key: string]: any; };
    /**
     * UUID of the associated company
     * @type {string}
     * @memberof PolicyRead
     */
    'company_id': string;
    /**
     * UUID of the user who created the policy
     * @type {string}
     * @memberof PolicyRead
     */
    'created_by': string;
    /**
     * Timestamp when the policy was created
     * @type {string}
     * @memberof PolicyRead
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface PolicyUpdate
 */
export interface PolicyUpdate {
    /**
     * 
     * @type {string}
     * @memberof PolicyUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PolicyUpdate
     */
    'type'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PolicyUpdate
     */
    'content'?: { [key: string]: any; } | null;
}
/**
 * Register schema for user registration. Attributes:     - email: EmailStr     - password: SecretStr     - password_repeat: SecretStr     - name: str | None     - phone: str | None     - turnstile_token: str
 * @export
 * @interface RegisterSchema
 */
export interface RegisterSchema {
    /**
     * 
     * @type {string}
     * @memberof RegisterSchema
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterSchema
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterSchema
     */
    'turnstile_token': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterSchema
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterSchema
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterSchema
     */
    'password_repeat': string;
}
/**
 * 
 * @export
 * @interface RemoveFromCompany
 */
export interface RemoveFromCompany {
    /**
     * 
     * @type {string}
     * @memberof RemoveFromCompany
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof RemoveFromCompany
     */
    'company_id': string;
}
/**
 * 
 * @export
 * @interface ResponseGetCheckoutSessionPaymentsCheckoutGet
 */
export interface ResponseGetCheckoutSessionPaymentsCheckoutGet {
    /**
     * 
     * @type {string}
     * @memberof ResponseGetCheckoutSessionPaymentsCheckoutGet
     */
    'checkout_url': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetCheckoutSessionPaymentsCheckoutGet
     */
    'session_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetCheckoutSessionPaymentsCheckoutGet
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ResponseGetCustomerManagementSessionPaymentsCustomerManagementGet
 */
export interface ResponseGetCustomerManagementSessionPaymentsCustomerManagementGet {
    /**
     * 
     * @type {string}
     * @memberof ResponseGetCustomerManagementSessionPaymentsCustomerManagementGet
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetCustomerManagementSessionPaymentsCustomerManagementGet
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface RolesWithUser
 */
export interface RolesWithUser {
    /**
     * 
     * @type {string}
     * @memberof RolesWithUser
     */
    'role': string;
    /**
     * 
     * @type {UserBase}
     * @memberof RolesWithUser
     */
    'user': UserBase;
}
/**
 * 
 * @export
 * @interface UpdateControlSchema
 */
export interface UpdateControlSchema {
    /**
     * 
     * @type {string}
     * @memberof UpdateControlSchema
     */
    'id': string;
    /**
     * 
     * @type {ControlStatus}
     * @memberof UpdateControlSchema
     */
    'status'?: ControlStatus | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateControlSchema
     */
    'note'?: string | null;
}


/**
 * 
 * @export
 * @interface UpdatePassword
 */
export interface UpdatePassword {
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    'old_password': string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface UserBase
 */
export interface UserBase {
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBase
     */
    'phone'?: string | null;
}
/**
 * 
 * @export
 * @interface UserInDBBase
 */
export interface UserInDBBase {
    /**
     * 
     * @type {string}
     * @memberof UserInDBBase
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserInDBBase
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserInDBBase
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserInDBBase
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInDBBase
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserInDBBase
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface UserPermissionsWithCompany
 */
export interface UserPermissionsWithCompany {
    /**
     * 
     * @type {string}
     * @memberof UserPermissionsWithCompany
     */
    'role': string | null;
    /**
     * 
     * @type {CompanyInDBBase}
     * @memberof UserPermissionsWithCompany
     */
    'company': CompanyInDBBase | null;
}
/**
 * 
 * @export
 * @interface UserRole
 */
export interface UserRole {
    /**
     * 
     * @type {string}
     * @memberof UserRole
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'phone'?: string | null;
}
/**
 * 
 * @export
 * @interface UserWithRelations
 */
export interface UserWithRelations {
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserWithRelations
     */
    'role'?: string;
    /**
     * 
     * @type {Array<UserPermissionsWithCompany>}
     * @memberof UserWithRelations
     */
    'company_permissions': Array<UserPermissionsWithCompany> | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete user session
         * @summary Delete Session
         * @param {string | null} [sessionIdToDelete] 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionV1AuthSessionDelete: async (sessionIdToDelete?: string | null, sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user sessions
         * @summary Delete Sessions
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsV1AuthSessionsDelete: async (sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user sessions
         * @summary Get Sessions
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsV1AuthSessionsGet: async (sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handles the callback from GitHub OAuth.
         * @summary Github Callback
         * @param {string} code 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallbackV1AuthGithubCallbackPost: async (code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('githubCallbackV1AuthGithubCallbackPost', 'code', code)
            const localVarPath = `/v1/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            if (cFConnectingIP != null) {
                localVarHeaderParameter['CF-Connecting-IP'] = String(cFConnectingIP);
            }
            if (cFIPCountry != null) {
                localVarHeaderParameter['CF-IPCountry'] = String(cFIPCountry);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to GitHub\'s OAuth consent screen.
         * @summary Github Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLoginV1AuthGithubLoginGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/github/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Handles the callback from Google OAuth.
         * @summary Google Callback
         * @param {string} code 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleCallbackV1AuthGoogleCallbackPost: async (code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('googleCallbackV1AuthGoogleCallbackPost', 'code', code)
            const localVarPath = `/v1/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            if (cFConnectingIP != null) {
                localVarHeaderParameter['CF-Connecting-IP'] = String(cFConnectingIP);
            }
            if (cFIPCountry != null) {
                localVarHeaderParameter['CF-IPCountry'] = String(cFIPCountry);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to Google\'s OAuth consent screen.
         * @summary Google Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleLoginV1AuthGoogleLoginGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/google/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LoginSchema} loginSchema 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginV1AuthLoginPost: async (loginSchema: LoginSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginSchema' is not null or undefined
            assertParamExists('loginV1AuthLoginPost', 'loginSchema', loginSchema)
            const localVarPath = `/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            if (cFConnectingIP != null) {
                localVarHeaderParameter['CF-Connecting-IP'] = String(cFConnectingIP);
            }
            if (cFIPCountry != null) {
                localVarHeaderParameter['CF-IPCountry'] = String(cFIPCountry);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout user
         * @summary Logout
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutV1AuthLogoutPost: async (sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {RegisterSchema} registerSchema 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerV1AuthRegisterPost: async (registerSchema: RegisterSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerSchema' is not null or undefined
            assertParamExists('registerV1AuthRegisterPost', 'registerSchema', registerSchema)
            const localVarPath = `/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (userAgent != null) {
                localVarHeaderParameter['User-Agent'] = String(userAgent);
            }
            if (cFConnectingIP != null) {
                localVarHeaderParameter['CF-Connecting-IP'] = String(cFConnectingIP);
            }
            if (cFIPCountry != null) {
                localVarHeaderParameter['CF-IPCountry'] = String(cFIPCountry);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete user session
         * @summary Delete Session
         * @param {string | null} [sessionIdToDelete] 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionV1AuthSessionDelete(sessionIdToDelete?: string | null, sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionV1AuthSessionDelete(sessionIdToDelete, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteSessionV1AuthSessionDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user sessions
         * @summary Delete Sessions
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSessionsV1AuthSessionsDelete(sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSessionsV1AuthSessionsDelete(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.deleteSessionsV1AuthSessionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user sessions
         * @summary Get Sessions
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionsV1AuthSessionsGet(sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: string | null; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionsV1AuthSessionsGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getSessionsV1AuthSessionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handles the callback from GitHub OAuth.
         * @summary Github Callback
         * @param {string} code 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubCallbackV1AuthGithubCallbackPost(code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubCallbackV1AuthGithubCallbackPost(code, userAgent, cFConnectingIP, cFIPCountry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.githubCallbackV1AuthGithubCallbackPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to GitHub\'s OAuth consent screen.
         * @summary Github Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async githubLoginV1AuthGithubLoginGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.githubLoginV1AuthGithubLoginGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.githubLoginV1AuthGithubLoginGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Handles the callback from Google OAuth.
         * @summary Google Callback
         * @param {string} code 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleCallbackV1AuthGoogleCallbackPost(code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleCallbackV1AuthGoogleCallbackPost(code, userAgent, cFConnectingIP, cFIPCountry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.googleCallbackV1AuthGoogleCallbackPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to Google\'s OAuth consent screen.
         * @summary Google Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async googleLoginV1AuthGoogleLoginGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.googleLoginV1AuthGoogleLoginGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.googleLoginV1AuthGoogleLoginGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {LoginSchema} loginSchema 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginV1AuthLoginPost(loginSchema: LoginSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginV1AuthLoginPost(loginSchema, userAgent, cFConnectingIP, cFIPCountry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginV1AuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout user
         * @summary Logout
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutV1AuthLogoutPost(sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutV1AuthLogoutPost(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logoutV1AuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register
         * @param {RegisterSchema} registerSchema 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerV1AuthRegisterPost(registerSchema: RegisterSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerV1AuthRegisterPost(registerSchema, userAgent, cFConnectingIP, cFIPCountry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.registerV1AuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Delete user session
         * @summary Delete Session
         * @param {string | null} [sessionIdToDelete] 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionV1AuthSessionDelete(sessionIdToDelete?: string | null, sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.deleteSessionV1AuthSessionDelete(sessionIdToDelete, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user sessions
         * @summary Delete Sessions
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSessionsV1AuthSessionsDelete(sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.deleteSessionsV1AuthSessionsDelete(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user sessions
         * @summary Get Sessions
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionsV1AuthSessionsGet(sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: string | null; }>> {
            return localVarFp.getSessionsV1AuthSessionsGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Handles the callback from GitHub OAuth.
         * @summary Github Callback
         * @param {string} code 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubCallbackV1AuthGithubCallbackPost(code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.githubCallbackV1AuthGithubCallbackPost(code, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to GitHub\'s OAuth consent screen.
         * @summary Github Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        githubLoginV1AuthGithubLoginGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.githubLoginV1AuthGithubLoginGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Handles the callback from Google OAuth.
         * @summary Google Callback
         * @param {string} code 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleCallbackV1AuthGoogleCallbackPost(code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.googleCallbackV1AuthGoogleCallbackPost(code, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to Google\'s OAuth consent screen.
         * @summary Google Login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleLoginV1AuthGoogleLoginGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.googleLoginV1AuthGoogleLoginGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LoginSchema} loginSchema 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginV1AuthLoginPost(loginSchema: LoginSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationSuccess> {
            return localVarFp.loginV1AuthLoginPost(loginSchema, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout user
         * @summary Logout
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutV1AuthLogoutPost(sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.logoutV1AuthLogoutPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {RegisterSchema} registerSchema 
         * @param {string | null} [userAgent] 
         * @param {string | null} [cFConnectingIP] 
         * @param {string | null} [cFIPCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerV1AuthRegisterPost(registerSchema: RegisterSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationSuccess> {
            return localVarFp.registerV1AuthRegisterPost(registerSchema, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Delete user session
     * @summary Delete Session
     * @param {string | null} [sessionIdToDelete] 
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteSessionV1AuthSessionDelete(sessionIdToDelete?: string | null, sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteSessionV1AuthSessionDelete(sessionIdToDelete, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user sessions
     * @summary Delete Sessions
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public deleteSessionsV1AuthSessionsDelete(sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).deleteSessionsV1AuthSessionsDelete(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user sessions
     * @summary Get Sessions
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getSessionsV1AuthSessionsGet(sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getSessionsV1AuthSessionsGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handles the callback from GitHub OAuth.
     * @summary Github Callback
     * @param {string} code 
     * @param {string | null} [userAgent] 
     * @param {string | null} [cFConnectingIP] 
     * @param {string | null} [cFIPCountry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubCallbackV1AuthGithubCallbackPost(code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubCallbackV1AuthGithubCallbackPost(code, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to GitHub\'s OAuth consent screen.
     * @summary Github Login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public githubLoginV1AuthGithubLoginGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).githubLoginV1AuthGithubLoginGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Handles the callback from Google OAuth.
     * @summary Google Callback
     * @param {string} code 
     * @param {string | null} [userAgent] 
     * @param {string | null} [cFConnectingIP] 
     * @param {string | null} [cFIPCountry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public googleCallbackV1AuthGoogleCallbackPost(code: string, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).googleCallbackV1AuthGoogleCallbackPost(code, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to Google\'s OAuth consent screen.
     * @summary Google Login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public googleLoginV1AuthGoogleLoginGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).googleLoginV1AuthGoogleLoginGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LoginSchema} loginSchema 
     * @param {string | null} [userAgent] 
     * @param {string | null} [cFConnectingIP] 
     * @param {string | null} [cFIPCountry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginV1AuthLoginPost(loginSchema: LoginSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginV1AuthLoginPost(loginSchema, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout user
     * @summary Logout
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logoutV1AuthLogoutPost(sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logoutV1AuthLogoutPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {RegisterSchema} registerSchema 
     * @param {string | null} [userAgent] 
     * @param {string | null} [cFConnectingIP] 
     * @param {string | null} [cFIPCountry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerV1AuthRegisterPost(registerSchema: RegisterSchema, userAgent?: string | null, cFConnectingIP?: string | null, cFIPCountry?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerV1AuthRegisterPost(registerSchema, userAgent, cFConnectingIP, cFIPCountry, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompanyApi - axios parameter creator
 * @export
 */
export const CompanyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Company
         * @param {CompanyCreate} companyCreate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyV1CompanyCreatePost: async (companyCreate: CompanyCreate, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyCreate' is not null or undefined
            assertParamExists('createCompanyV1CompanyCreatePost', 'companyCreate', companyCreate)
            const localVarPath = `/v1/company/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Companies
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompaniesV1CompanyListGet: async (page?: number, limit?: number, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/company/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Company
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyV1CompanyGetCompanyIdGet: async (companyId: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompanyV1CompanyGetCompanyIdGet', 'companyId', companyId)
            const localVarPath = `/v1/company/get/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Controls
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlsV1CompanyControlsCompanyIdGet: async (companyId: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getControlsV1CompanyControlsCompanyIdGet', 'companyId', companyId)
            const localVarPath = `/v1/company/controls/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Policies
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesV1CompanyPoliciesGet: async (page?: number, limit?: number, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/company/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Company
         * @param {CompanyUpdate} companyUpdate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyV1CompanyUpdatePatch: async (companyUpdate: CompanyUpdate, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyUpdate' is not null or undefined
            assertParamExists('updateCompanyV1CompanyUpdatePatch', 'companyUpdate', companyUpdate)
            const localVarPath = `/v1/company/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyApi - functional programming interface
 * @export
 */
export const CompanyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Company
         * @param {CompanyCreate} companyCreate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompanyV1CompanyCreatePost(companyCreate: CompanyCreate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyInDBBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompanyV1CompanyCreatePost(companyCreate, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyApi.createCompanyV1CompanyCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Companies
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompaniesV1CompanyListGet(page?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CompanyInDBBase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompaniesV1CompanyListGet(page, limit, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyApi.getCompaniesV1CompanyListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Company
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyV1CompanyGetCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyWithRoles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyV1CompanyGetCompanyIdGet(companyId, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyApi.getCompanyV1CompanyGetCompanyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Controls
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlsV1CompanyControlsCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyWithControls>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlsV1CompanyControlsCompanyIdGet(companyId, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyApi.getControlsV1CompanyControlsCompanyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Policies
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoliciesV1CompanyPoliciesGet(page?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PolicyRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoliciesV1CompanyPoliciesGet(page, limit, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyApi.getPoliciesV1CompanyPoliciesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Company
         * @param {CompanyUpdate} companyUpdate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyV1CompanyUpdatePatch(companyUpdate: CompanyUpdate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyInDBBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyV1CompanyUpdatePatch(companyUpdate, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompanyApi.updateCompanyV1CompanyUpdatePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompanyApi - factory interface
 * @export
 */
export const CompanyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Company
         * @param {CompanyCreate} companyCreate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompanyV1CompanyCreatePost(companyCreate: CompanyCreate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CompanyInDBBase> {
            return localVarFp.createCompanyV1CompanyCreatePost(companyCreate, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Companies
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompaniesV1CompanyListGet(page?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CompanyInDBBase>> {
            return localVarFp.getCompaniesV1CompanyListGet(page, limit, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Company
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyV1CompanyGetCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CompanyWithRoles> {
            return localVarFp.getCompanyV1CompanyGetCompanyIdGet(companyId, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Controls
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlsV1CompanyControlsCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CompanyWithControls> {
            return localVarFp.getControlsV1CompanyControlsCompanyIdGet(companyId, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Policies
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoliciesV1CompanyPoliciesGet(page?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PolicyRead>> {
            return localVarFp.getPoliciesV1CompanyPoliciesGet(page, limit, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Company
         * @param {CompanyUpdate} companyUpdate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyV1CompanyUpdatePatch(companyUpdate: CompanyUpdate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CompanyInDBBase> {
            return localVarFp.updateCompanyV1CompanyUpdatePatch(companyUpdate, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompanyApi - object-oriented interface
 * @export
 * @class CompanyApi
 * @extends {BaseAPI}
 */
export class CompanyApi extends BaseAPI {
    /**
     * 
     * @summary Create Company
     * @param {CompanyCreate} companyCreate 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public createCompanyV1CompanyCreatePost(companyCreate: CompanyCreate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return CompanyApiFp(this.configuration).createCompanyV1CompanyCreatePost(companyCreate, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Companies
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getCompaniesV1CompanyListGet(page?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return CompanyApiFp(this.configuration).getCompaniesV1CompanyListGet(page, limit, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Company
     * @param {string} companyId 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getCompanyV1CompanyGetCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return CompanyApiFp(this.configuration).getCompanyV1CompanyGetCompanyIdGet(companyId, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Controls
     * @param {string} companyId 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getControlsV1CompanyControlsCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return CompanyApiFp(this.configuration).getControlsV1CompanyControlsCompanyIdGet(companyId, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Policies
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public getPoliciesV1CompanyPoliciesGet(page?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return CompanyApiFp(this.configuration).getPoliciesV1CompanyPoliciesGet(page, limit, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Company
     * @param {CompanyUpdate} companyUpdate 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyApi
     */
    public updateCompanyV1CompanyUpdatePatch(companyUpdate: CompanyUpdate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return CompanyApiFp(this.configuration).updateCompanyV1CompanyUpdatePatch(companyUpdate, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ControlsApi - axios parameter creator
 * @export
 */
export const ControlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Control
         * @param {string} controlId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlV1ControlsControlIdGet: async (controlId: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'controlId' is not null or undefined
            assertParamExists('getControlV1ControlsControlIdGet', 'controlId', controlId)
            const localVarPath = `/v1/controls/{control_id}`
                .replace(`{${"control_id"}}`, encodeURIComponent(String(controlId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Control
         * @param {UpdateControlSchema} updateControlSchema 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlV1ControlsUpdatePatch: async (updateControlSchema: UpdateControlSchema, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateControlSchema' is not null or undefined
            assertParamExists('updateControlV1ControlsUpdatePatch', 'updateControlSchema', updateControlSchema)
            const localVarPath = `/v1/controls/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateControlSchema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControlsApi - functional programming interface
 * @export
 */
export const ControlsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControlsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Control
         * @param {string} controlId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlV1ControlsControlIdGet(controlId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlV1ControlsControlIdGet(controlId, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlsApi.getControlV1ControlsControlIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Control
         * @param {UpdateControlSchema} updateControlSchema 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateControlV1ControlsUpdatePatch(updateControlSchema: UpdateControlSchema, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateControlV1ControlsUpdatePatch(updateControlSchema, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ControlsApi.updateControlV1ControlsUpdatePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ControlsApi - factory interface
 * @export
 */
export const ControlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControlsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Control
         * @param {string} controlId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlV1ControlsControlIdGet(controlId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetControl> {
            return localVarFp.getControlV1ControlsControlIdGet(controlId, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Control
         * @param {UpdateControlSchema} updateControlSchema 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateControlV1ControlsUpdatePatch(updateControlSchema: UpdateControlSchema, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetControl> {
            return localVarFp.updateControlV1ControlsUpdatePatch(updateControlSchema, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControlsApi - object-oriented interface
 * @export
 * @class ControlsApi
 * @extends {BaseAPI}
 */
export class ControlsApi extends BaseAPI {
    /**
     * 
     * @summary Get Control
     * @param {string} controlId 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlsApi
     */
    public getControlV1ControlsControlIdGet(controlId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return ControlsApiFp(this.configuration).getControlV1ControlsControlIdGet(controlId, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Control
     * @param {UpdateControlSchema} updateControlSchema 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlsApi
     */
    public updateControlV1ControlsUpdatePatch(updateControlSchema: UpdateControlSchema, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return ControlsApiFp(this.configuration).updateControlV1ControlsUpdatePatch(updateControlSchema, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Db Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDbHealthHealthDbGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/db`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthHealthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Listmonk Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListmonkHealthHealthListmonkGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/listmonk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Redis Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedisHealthHealthRedisGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/redis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Db Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDbHealthHealthDbGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDbHealthHealthDbGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getDbHealthHealthDbGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthHealthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthHealthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getHealthHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Listmonk Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListmonkHealthHealthListmonkGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListmonkHealthHealthListmonkGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getListmonkHealthHealthListmonkGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Redis Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRedisHealthHealthRedisGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRedisHealthHealthRedisGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRedisHealthHealthRedisGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Db Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDbHealthHealthDbGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getDbHealthHealthDbGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthHealthGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getHealthHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Listmonk Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListmonkHealthHealthListmonkGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getListmonkHealthHealthListmonkGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Redis Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRedisHealthHealthRedisGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getRedisHealthHealthRedisGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get Db Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDbHealthHealthDbGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDbHealthHealthDbGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHealthHealthGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHealthHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Listmonk Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getListmonkHealthHealthListmonkGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getListmonkHealthHealthListmonkGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Redis Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRedisHealthHealthRedisGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRedisHealthHealthRedisGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EvidenceApi - axios parameter creator
 * @export
 */
export const EvidenceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Evidence
         * @param {string} evidenceId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvidenceV1EvidenceDeleteDelete: async (evidenceId: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'evidenceId' is not null or undefined
            assertParamExists('deleteEvidenceV1EvidenceDeleteDelete', 'evidenceId', evidenceId)
            const localVarPath = `/v1/evidence/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (evidenceId !== undefined) { 
                localVarFormParams.set('evidence_id', evidenceId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Evidence Files
         * @param {string} evidenceId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvidenceFilesV1EvidenceFileEvidenceIdGet: async (evidenceId: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'evidenceId' is not null or undefined
            assertParamExists('getEvidenceFilesV1EvidenceFileEvidenceIdGet', 'evidenceId', evidenceId)
            const localVarPath = `/v1/evidence/file/{evidence_id}`
                .replace(`{${"evidence_id"}}`, encodeURIComponent(String(evidenceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Company Evidence
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCompanyEvidenceV1EvidenceCompanyCompanyIdGet: async (companyId: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('listCompanyEvidenceV1EvidenceCompanyCompanyIdGet', 'companyId', companyId)
            const localVarPath = `/v1/evidence/company/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Evidence
         * @param {string} evidenceId 
         * @param {string} text 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvidenceV1EvidenceUpdatePut: async (evidenceId: string, text: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'evidenceId' is not null or undefined
            assertParamExists('updateEvidenceV1EvidenceUpdatePut', 'evidenceId', evidenceId)
            // verify required parameter 'text' is not null or undefined
            assertParamExists('updateEvidenceV1EvidenceUpdatePut', 'text', text)
            const localVarPath = `/v1/evidence/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (evidenceId !== undefined) { 
                localVarFormParams.set('evidence_id', evidenceId as any);
            }
    
            if (text !== undefined) { 
                localVarFormParams.set('text', text as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Evidence
         * @param {string} companyId 
         * @param {string} controlId 
         * @param {File | null} file 
         * @param {string | null} text 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadEvidenceV1EvidenceUploadPost: async (companyId: string, controlId: string, file: File | null, text: string | null, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('uploadEvidenceV1EvidenceUploadPost', 'companyId', companyId)
            // verify required parameter 'controlId' is not null or undefined
            assertParamExists('uploadEvidenceV1EvidenceUploadPost', 'controlId', controlId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadEvidenceV1EvidenceUploadPost', 'file', file)
            // verify required parameter 'text' is not null or undefined
            assertParamExists('uploadEvidenceV1EvidenceUploadPost', 'text', text)
            const localVarPath = `/v1/evidence/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (companyId !== undefined) { 
                localVarFormParams.set('company_id', companyId as any);
            }
    
            if (controlId !== undefined) { 
                localVarFormParams.set('control_id', controlId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.set('file', file as any);
            }
    
            if (text !== undefined) { 
                localVarFormParams.set('text', text as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EvidenceApi - functional programming interface
 * @export
 */
export const EvidenceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EvidenceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Evidence
         * @param {string} evidenceId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEvidenceV1EvidenceDeleteDelete(evidenceId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvidenceV1EvidenceDeleteDelete(evidenceId, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvidenceApi.deleteEvidenceV1EvidenceDeleteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Evidence Files
         * @param {string} evidenceId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvidenceFilesV1EvidenceFileEvidenceIdGet(evidenceId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileDownload>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvidenceFilesV1EvidenceFileEvidenceIdGet(evidenceId, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvidenceApi.getEvidenceFilesV1EvidenceFileEvidenceIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Company Evidence
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCompanyEvidenceV1EvidenceCompanyCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EvidenceBase>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCompanyEvidenceV1EvidenceCompanyCompanyIdGet(companyId, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvidenceApi.listCompanyEvidenceV1EvidenceCompanyCompanyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Evidence
         * @param {string} evidenceId 
         * @param {string} text 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvidenceV1EvidenceUpdatePut(evidenceId: string, text: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvidenceBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEvidenceV1EvidenceUpdatePut(evidenceId, text, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvidenceApi.updateEvidenceV1EvidenceUpdatePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload Evidence
         * @param {string} companyId 
         * @param {string} controlId 
         * @param {File | null} file 
         * @param {string | null} text 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadEvidenceV1EvidenceUploadPost(companyId: string, controlId: string, file: File | null, text: string | null, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvidenceBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadEvidenceV1EvidenceUploadPost(companyId, controlId, file, text, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EvidenceApi.uploadEvidenceV1EvidenceUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EvidenceApi - factory interface
 * @export
 */
export const EvidenceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EvidenceApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Evidence
         * @param {string} evidenceId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvidenceV1EvidenceDeleteDelete(evidenceId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEvidenceV1EvidenceDeleteDelete(evidenceId, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Evidence Files
         * @param {string} evidenceId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvidenceFilesV1EvidenceFileEvidenceIdGet(evidenceId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FileDownload>> {
            return localVarFp.getEvidenceFilesV1EvidenceFileEvidenceIdGet(evidenceId, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Company Evidence
         * @param {string} companyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCompanyEvidenceV1EvidenceCompanyCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EvidenceBase>> {
            return localVarFp.listCompanyEvidenceV1EvidenceCompanyCompanyIdGet(companyId, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Evidence
         * @param {string} evidenceId 
         * @param {string} text 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvidenceV1EvidenceUpdatePut(evidenceId: string, text: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<EvidenceBase> {
            return localVarFp.updateEvidenceV1EvidenceUpdatePut(evidenceId, text, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload Evidence
         * @param {string} companyId 
         * @param {string} controlId 
         * @param {File | null} file 
         * @param {string | null} text 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadEvidenceV1EvidenceUploadPost(companyId: string, controlId: string, file: File | null, text: string | null, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<EvidenceBase> {
            return localVarFp.uploadEvidenceV1EvidenceUploadPost(companyId, controlId, file, text, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EvidenceApi - object-oriented interface
 * @export
 * @class EvidenceApi
 * @extends {BaseAPI}
 */
export class EvidenceApi extends BaseAPI {
    /**
     * 
     * @summary Delete Evidence
     * @param {string} evidenceId 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvidenceApi
     */
    public deleteEvidenceV1EvidenceDeleteDelete(evidenceId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return EvidenceApiFp(this.configuration).deleteEvidenceV1EvidenceDeleteDelete(evidenceId, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Evidence Files
     * @param {string} evidenceId 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvidenceApi
     */
    public getEvidenceFilesV1EvidenceFileEvidenceIdGet(evidenceId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return EvidenceApiFp(this.configuration).getEvidenceFilesV1EvidenceFileEvidenceIdGet(evidenceId, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Company Evidence
     * @param {string} companyId 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvidenceApi
     */
    public listCompanyEvidenceV1EvidenceCompanyCompanyIdGet(companyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return EvidenceApiFp(this.configuration).listCompanyEvidenceV1EvidenceCompanyCompanyIdGet(companyId, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Evidence
     * @param {string} evidenceId 
     * @param {string} text 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvidenceApi
     */
    public updateEvidenceV1EvidenceUpdatePut(evidenceId: string, text: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return EvidenceApiFp(this.configuration).updateEvidenceV1EvidenceUpdatePut(evidenceId, text, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload Evidence
     * @param {string} companyId 
     * @param {string} controlId 
     * @param {File | null} file 
     * @param {string | null} text 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EvidenceApi
     */
    public uploadEvidenceV1EvidenceUploadPost(companyId: string, controlId: string, file: File | null, text: string | null, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return EvidenceApiFp(this.configuration).uploadEvidenceV1EvidenceUploadPost(companyId, controlId, file, text, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Checkout Session
         * @param {string} userId 
         * @param {string} companyId 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckoutSessionPaymentsCheckoutGet: async (userId: string, companyId: string, productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getCheckoutSessionPaymentsCheckoutGet', 'userId', userId)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCheckoutSessionPaymentsCheckoutGet', 'companyId', companyId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getCheckoutSessionPaymentsCheckoutGet', 'productId', productId)
            const localVarPath = `/payments/checkout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (companyId !== undefined) {
                localVarQueryParameter['company_id'] = companyId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['product_id'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Customer Management Session
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerManagementSessionPaymentsCustomerManagementGet: async (authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments/customer/management`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookPaymentsWebhookPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Checkout Session
         * @param {string} userId 
         * @param {string} companyId 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckoutSessionPaymentsCheckoutGet(userId: string, companyId: string, productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetCheckoutSessionPaymentsCheckoutGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckoutSessionPaymentsCheckoutGet(userId, companyId, productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getCheckoutSessionPaymentsCheckoutGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Customer Management Session
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerManagementSessionPaymentsCustomerManagementGet(authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetCustomerManagementSessionPaymentsCustomerManagementGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerManagementSessionPaymentsCustomerManagementGet(authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getCustomerManagementSessionPaymentsCustomerManagementGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookPaymentsWebhookPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookPaymentsWebhookPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.webhookPaymentsWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Checkout Session
         * @param {string} userId 
         * @param {string} companyId 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckoutSessionPaymentsCheckoutGet(userId: string, companyId: string, productId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGetCheckoutSessionPaymentsCheckoutGet> {
            return localVarFp.getCheckoutSessionPaymentsCheckoutGet(userId, companyId, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Customer Management Session
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerManagementSessionPaymentsCustomerManagementGet(authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGetCustomerManagementSessionPaymentsCustomerManagementGet> {
            return localVarFp.getCustomerManagementSessionPaymentsCustomerManagementGet(authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookPaymentsWebhookPost(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.webhookPaymentsWebhookPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Get Checkout Session
     * @param {string} userId 
     * @param {string} companyId 
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getCheckoutSessionPaymentsCheckoutGet(userId: string, companyId: string, productId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getCheckoutSessionPaymentsCheckoutGet(userId, companyId, productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Customer Management Session
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getCustomerManagementSessionPaymentsCustomerManagementGet(authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getCustomerManagementSessionPaymentsCustomerManagementGet(authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public webhookPaymentsWebhookPost(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).webhookPaymentsWebhookPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Policy
         * @param {PolicyCreate} policyCreate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyV1PoliciesCreatePost: async (policyCreate: PolicyCreate, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyCreate' is not null or undefined
            assertParamExists('createPolicyV1PoliciesCreatePost', 'policyCreate', policyCreate)
            const localVarPath = `/v1/policies/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Policy
         * @param {string} policyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyV1PoliciesPolicyIdDelete: async (policyId: string, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('deletePolicyV1PoliciesPolicyIdDelete', 'policyId', policyId)
            const localVarPath = `/v1/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Company Policies
         * @param {string} companyId 
         * @param {number} [skip] Number of records to skip for pagination
         * @param {number} [limit] Maximum number of records to return
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPoliciesV1PoliciesCompanyCompanyIdGet: async (companyId: string, skip?: number, limit?: number, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompanyPoliciesV1PoliciesCompanyCompanyIdGet', 'companyId', companyId)
            const localVarPath = `/v1/policies/company/{company_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Policy
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyV1PoliciesPolicyIdGet: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('getPolicyV1PoliciesPolicyIdGet', 'policyId', policyId)
            const localVarPath = `/v1/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Policy
         * @param {string} policyId 
         * @param {PolicyUpdate} policyUpdate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyV1PoliciesPolicyIdPut: async (policyId: string, policyUpdate: PolicyUpdate, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('updatePolicyV1PoliciesPolicyIdPut', 'policyId', policyId)
            // verify required parameter 'policyUpdate' is not null or undefined
            assertParamExists('updatePolicyV1PoliciesPolicyIdPut', 'policyUpdate', policyUpdate)
            const localVarPath = `/v1/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Policy
         * @param {PolicyCreate} policyCreate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicyV1PoliciesCreatePost(policyCreate: PolicyCreate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicyV1PoliciesCreatePost(policyCreate, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createPolicyV1PoliciesCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Policy
         * @param {string} policyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicyV1PoliciesPolicyIdDelete(policyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicyV1PoliciesPolicyIdDelete(policyId, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.deletePolicyV1PoliciesPolicyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Company Policies
         * @param {string} companyId 
         * @param {number} [skip] Number of records to skip for pagination
         * @param {number} [limit] Maximum number of records to return
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyPoliciesV1PoliciesCompanyCompanyIdGet(companyId: string, skip?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PolicyRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyPoliciesV1PoliciesCompanyCompanyIdGet(companyId, skip, limit, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getCompanyPoliciesV1PoliciesCompanyCompanyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Policy
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyV1PoliciesPolicyIdGet(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyV1PoliciesPolicyIdGet(policyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getPolicyV1PoliciesPolicyIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Policy
         * @param {string} policyId 
         * @param {PolicyUpdate} policyUpdate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicyV1PoliciesPolicyIdPut(policyId: string, policyUpdate: PolicyUpdate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicyV1PoliciesPolicyIdPut(policyId, policyUpdate, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updatePolicyV1PoliciesPolicyIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Policy
         * @param {PolicyCreate} policyCreate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicyV1PoliciesCreatePost(policyCreate: PolicyCreate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRead> {
            return localVarFp.createPolicyV1PoliciesCreatePost(policyCreate, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Policy
         * @param {string} policyId 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicyV1PoliciesPolicyIdDelete(policyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePolicyV1PoliciesPolicyIdDelete(policyId, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Company Policies
         * @param {string} companyId 
         * @param {number} [skip] Number of records to skip for pagination
         * @param {number} [limit] Maximum number of records to return
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPoliciesV1PoliciesCompanyCompanyIdGet(companyId: string, skip?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PolicyRead>> {
            return localVarFp.getCompanyPoliciesV1PoliciesCompanyCompanyIdGet(companyId, skip, limit, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Policy
         * @param {string} policyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyV1PoliciesPolicyIdGet(policyId: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRead> {
            return localVarFp.getPolicyV1PoliciesPolicyIdGet(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Policy
         * @param {string} policyId 
         * @param {PolicyUpdate} policyUpdate 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicyV1PoliciesPolicyIdPut(policyId: string, policyUpdate: PolicyUpdate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRead> {
            return localVarFp.updatePolicyV1PoliciesPolicyIdPut(policyId, policyUpdate, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * 
     * @summary Create Policy
     * @param {PolicyCreate} policyCreate 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicyV1PoliciesCreatePost(policyCreate: PolicyCreate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicyV1PoliciesCreatePost(policyCreate, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Policy
     * @param {string} policyId 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicyV1PoliciesPolicyIdDelete(policyId: string, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicyV1PoliciesPolicyIdDelete(policyId, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Company Policies
     * @param {string} companyId 
     * @param {number} [skip] Number of records to skip for pagination
     * @param {number} [limit] Maximum number of records to return
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getCompanyPoliciesV1PoliciesCompanyCompanyIdGet(companyId: string, skip?: number, limit?: number, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getCompanyPoliciesV1PoliciesCompanyCompanyIdGet(companyId, skip, limit, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Policy
     * @param {string} policyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicyV1PoliciesPolicyIdGet(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicyV1PoliciesPolicyIdGet(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Policy
     * @param {string} policyId 
     * @param {PolicyUpdate} policyUpdate 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicyV1PoliciesPolicyIdPut(policyId: string, policyUpdate: PolicyUpdate, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicyV1PoliciesPolicyIdPut(policyId, policyUpdate, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add people to company
         * @summary Invite
         * @param {InviteToCompany} inviteToCompany 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteV1RolesInvitesPost: async (inviteToCompany: InviteToCompany, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteToCompany' is not null or undefined
            assertParamExists('inviteV1RolesInvitesPost', 'inviteToCompany', inviteToCompany)
            const localVarPath = `/v1/roles/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteToCompany, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove people from company
         * @summary Remove People
         * @param {RemoveFromCompany} removeFromCompany 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePeopleV1RolesInvitesDelete: async (removeFromCompany: RemoveFromCompany, authorization?: string, sessionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeFromCompany' is not null or undefined
            assertParamExists('removePeopleV1RolesInvitesDelete', 'removeFromCompany', removeFromCompany)
            const localVarPath = `/v1/roles/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeFromCompany, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add people to company
         * @summary Invite
         * @param {InviteToCompany} inviteToCompany 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteV1RolesInvitesPost(inviteToCompany: InviteToCompany, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteV1RolesInvitesPost(inviteToCompany, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.inviteV1RolesInvitesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove people from company
         * @summary Remove People
         * @param {RemoveFromCompany} removeFromCompany 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePeopleV1RolesInvitesDelete(removeFromCompany: RemoveFromCompany, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePeopleV1RolesInvitesDelete(removeFromCompany, authorization, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RolesApi.removePeopleV1RolesInvitesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Add people to company
         * @summary Invite
         * @param {InviteToCompany} inviteToCompany 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteV1RolesInvitesPost(inviteToCompany: InviteToCompany, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.inviteV1RolesInvitesPost(inviteToCompany, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove people from company
         * @summary Remove People
         * @param {RemoveFromCompany} removeFromCompany 
         * @param {string} [authorization] 
         * @param {string} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePeopleV1RolesInvitesDelete(removeFromCompany: RemoveFromCompany, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.removePeopleV1RolesInvitesDelete(removeFromCompany, authorization, sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Add people to company
     * @summary Invite
     * @param {InviteToCompany} inviteToCompany 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public inviteV1RolesInvitesPost(inviteToCompany: InviteToCompany, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).inviteV1RolesInvitesPost(inviteToCompany, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove people from company
     * @summary Remove People
     * @param {RemoveFromCompany} removeFromCompany 
     * @param {string} [authorization] 
     * @param {string} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public removePeopleV1RolesInvitesDelete(removeFromCompany: RemoveFromCompany, authorization?: string, sessionId?: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).removePeopleV1RolesInvitesDelete(removeFromCompany, authorization, sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change user password
         * @summary Change Password
         * @param {UpdatePassword} updatePassword 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordV1UserPasswordChangePatch: async (updatePassword: UpdatePassword, sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePassword' is not null or undefined
            assertParamExists('changePasswordV1UserPasswordChangePatch', 'updatePassword', updatePassword)
            const localVarPath = `/v1/user/password/change`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete user
         * @summary Delete User
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1UserDeleteDelete: async (sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user with relations
         * @summary Get User Dash
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDashV1UserMeDashGet: async (sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/me/dash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user
         * @summary Get User
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserV1UserMeGet: async (sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user
         * @summary Update User
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1UserUpdatePatch: async (userUpdate: UserUpdate, sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateUserV1UserUpdatePatch', 'userUpdate', userUpdate)
            const localVarPath = `/v1/user/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Change user password
         * @summary Change Password
         * @param {UpdatePassword} updatePassword 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordV1UserPasswordChangePatch(updatePassword: UpdatePassword, sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordV1UserPasswordChangePatch(updatePassword, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.changePasswordV1UserPasswordChangePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete user
         * @summary Delete User
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserV1UserDeleteDelete(sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserV1UserDeleteDelete(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteUserV1UserDeleteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user with relations
         * @summary Get User Dash
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDashV1UserMeDashGet(sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWithRelations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDashV1UserMeDashGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserDashV1UserMeDashGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user
         * @summary Get User
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserV1UserMeGet(sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInDBBase>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserV1UserMeGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserV1UserMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user
         * @summary Update User
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserV1UserUpdatePatch(userUpdate: UserUpdate, sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Details>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserV1UserUpdatePatch(userUpdate, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUserV1UserUpdatePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Change user password
         * @summary Change Password
         * @param {UpdatePassword} updatePassword 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordV1UserPasswordChangePatch(updatePassword: UpdatePassword, sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.changePasswordV1UserPasswordChangePatch(updatePassword, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete user
         * @summary Delete User
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserV1UserDeleteDelete(sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.deleteUserV1UserDeleteDelete(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user with relations
         * @summary Get User Dash
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDashV1UserMeDashGet(sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserWithRelations> {
            return localVarFp.getUserDashV1UserMeDashGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user
         * @summary Get User
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserV1UserMeGet(sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserInDBBase> {
            return localVarFp.getUserV1UserMeGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user
         * @summary Update User
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [sessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserV1UserUpdatePatch(userUpdate: UserUpdate, sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Details> {
            return localVarFp.updateUserV1UserUpdatePatch(userUpdate, sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Change user password
     * @summary Change Password
     * @param {UpdatePassword} updatePassword 
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changePasswordV1UserPasswordChangePatch(updatePassword: UpdatePassword, sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).changePasswordV1UserPasswordChangePatch(updatePassword, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete user
     * @summary Delete User
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUserV1UserDeleteDelete(sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUserV1UserDeleteDelete(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user with relations
     * @summary Get User Dash
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserDashV1UserMeDashGet(sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserDashV1UserMeDashGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user
     * @summary Get User
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserV1UserMeGet(sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserV1UserMeGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user
     * @summary Update User
     * @param {UserUpdate} userUpdate 
     * @param {string | null} [sessionId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserV1UserUpdatePatch(userUpdate: UserUpdate, sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserV1UserUpdatePatch(userUpdate, sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



